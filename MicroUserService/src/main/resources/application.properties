spring.application.name=USER-SERVICE

spring.datasource.url=jdbc:postgresql://localhost:5432/UserMicroService
spring.datasource.username=postgres
spring.datasource.password=postgres123
spring.datasource.driver-class-name=org.postgresql.Driver

server.port=8082
#Setting the Context Root Path
server.servlet.context-path=/user-service


spring.jpa.hibernate.ddl-auto=update


#It is the address of the Eureka Server that all Eureka Clients use to register and discover services.
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/


#This will fetch the service details running on this Port ....
spring.cloud.config.uri=http://localhost:8888
#Or we can make this URL dynamic By registering in Eureka and only providing the service name 
#spring.cloud.config.discovery.enabled=true
#spring.cloud.config.discovery.service-id=CONFIG-SERVER


# Enable all management endpoints
management.endpoints.enabled-by-default=true

# Expose all endpoints over HTTP
management.endpoints.web.exposure.include=*

# Enable detailed health information
management.endpoint.health.show-details=always

# -------- CircuitBreaker Config --------
# name of the circuit breaker = userService
resilience4j.circuitbreaker.instances.userService.registerHealthIndicator=true
 # % of failures before opening circuit
resilience4j.circuitbreaker.instances.userService.failureRateThreshold=50
 # calls taking longer than this are slow
resilience4j.circuitbreaker.instances.userService.slowCallDurationThreshold=2s
resilience4j.circuitbreaker.instances.userService.slowCallRateThreshold=50
# how long to wait before half-open
resilience4j.circuitbreaker.instances.userService.waitDurationInOpenState=20s
resilience4j.circuitbreaker.instances.userService.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.userService.slidingWindowSize=10
resilience4j.circuitbreaker.instances.userService.slidingWindowType=COUNT_BASED

# -------- Retry Config --------
# 1 initial + 2 retries
resilience4j.retry.instances.userService.maxAttempts=3
# wait 1s before retry
resilience4j.retry.instances.userService.waitDuration=1s
resilience4j.retry.instances.userService.enableExponentialBackoff=true
resilience4j.retry.instances.userService.exponentialBackoffMultiplier=2

resilience4j.retry.instances.userService.retryExceptions=java.lang.RuntimeException










#----------CircuitBreaker Config  Properties in Detail------------
#1. orderService:
#This is the name of your circuit breaker instance.
#Must match the name you use in @CircuitBreaker(name = "orderService").
#2. registerHealthIndicator: true
#Exposes the health of this circuit breaker via Spring Boot Actuator (/actuator/health).
#Useful for monitoring dashboards like Prometheus/Grafana.
#3. failureRateThreshold: 50
#If 50% or more calls fail within the sliding window, the circuit will open.
#Example: In a window of 10 calls \u2192 if 5 fail, breaker trips.
#4.  slowCallDurationThreshold: 2s
#Any call taking longer than 2 seconds is considered a \u201Cslow call.\u201D
#Helps detect latency issues (not just outright failures).
#5.  slowCallRateThreshold: 50
#If 50% or more of the calls are slow, circuit opens.
#Example: If 10 calls are made and 5 took >2s \u2192 circuit breaker trips.
#6.  aitDurationInOpenState: 5s
#How long the circuit stays open before moving to half-open.
#During these 5 seconds, all calls fail fast (go straight to fallback).
#7.  permittedNumberOfCallsInHalfOpenState: 3
#When moving to half-open, only 3 trial requests are allowed.
#If they succeed \u2192 circuit closes again.
#If they fail \u2192 circuit goes back to open.
#8.  slidingWindowSize: 10
#Number of calls to keep in the \u201Csliding window\u201D for calculating failure/slow rates.
#Here, it checks the last 10 calls.
#9.  slidingWindowType: COUNT_BASED
#Defines how the window is measured.
#COUNT_BASED: Tracks the last N calls (like last 10 requests).
#TIME_BASED: Tracks calls in the last N seconds (e.g., last 60 seconds).



